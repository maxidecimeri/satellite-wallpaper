# companion_selector.py
# Picks 2 geographically relevant static images to accompany a satellite view
# Requires the JSON sidecars generated by embed_geo_from_csv.py

import json
import random
import math
from pathlib import Path
from datetime import datetime, timezone, timedelta

# ---- Config ----
STATIC_ROOT = Path("static_backgrounds/manual_labels")  # where your labeled images live
SIDECAR_EXTS = {".jpg", ".jpeg", ".png", ".webp"}       # files we support sidecars for
OUTPUT_PICK_DIR = Path("output/companions")             # where to copy/record chosen companions (optional)
COPY_FILES = True                                       # set True to copy chosen files to OUTPUT_PICK_DIR/<view_key>

# Rough bboxes per view_key (same sanitize/build_view_key logic outcome)
# Format: (min_lat, max_lat, min_lon, max_lon)
VIEW_BBOX = {
    # GOES-East Full Disk (very rough Western Hemisphere coverage)
    "GOES-19_East_752W_Full_Disk_GeoColor_CIRA": (-60, 60, -140, 20),
    "GOES-19_East_752W_Full_Disk_Band_13_103_mm_Clean_IR_Longwave_Window": (-60, 60, -140, 20),
    "GOES-19_East_752W_Full_Disk_Airmass_EUMETSAT": (-60, 60, -140, 20),
    # Add more fine-grained views here as needed...
}

def hour_to_band(local_hour: int) -> str:
    """Map local hour ‚Üí time band."""
    # Adjust these to taste
    if 5 <= local_hour < 11:
        return "morning"
    if 11 <= local_hour < 17:
        return "afternoon"
    if 17 <= local_hour < 21:
        return "evening"
    return "evening"  # treat night as evening for now

def lon_to_local_hour(lon: float, now_utc: datetime | None = None) -> int:
    """Approximate local time from longitude (15¬∞ per hour)."""
    if now_utc is None:
        now_utc = datetime.now(timezone.utc)
    offset_hours = lon / 15.0
    local = now_utc + timedelta(hours=offset_hours)
    return local.hour

def inside_bbox(lat: float, lon: float, bbox: tuple[float, float, float, float]) -> bool:
    min_lat, max_lat, min_lon, max_lon = bbox
    return (min_lat <= lat <= max_lat) and (min_lon <= lon <= max_lon)

def scan_sidecars(root: Path):
    """Yield dicts with {path, lat, lon, time_band, place, level, region} from sidecars."""
    for img in root.rglob("*"):
        if img.suffix.lower() not in SIDECAR_EXTS:
            continue
        sidecar = img.with_suffix(img.suffix + ".json")
        if not sidecar.exists():
            continue
        try:
            meta = json.loads(sidecar.read_text(encoding="utf-8"))
        except Exception:
            continue
        lat = meta.get("lat")
        lon = meta.get("lon")
        if lat is None or lon is None:
            continue
        yield {
            "path": img,
            "lat": float(lat),
            "lon": float(lon),
            "time_band": (meta.get("time_band") or "").lower().strip(),
            "place": meta.get("place") or "",
            "level": (meta.get("match_level") or "").lower(),
            "region": meta.get("region") or "",
        }

def choose_companions_for_view(view_key: str, n: int = 2) -> list[Path]:
    """Pick up to n companion images for a given view_key."""
    bbox = VIEW_BBOX.get(view_key)
    if not bbox:
        print(f"‚ÑπÔ∏è  No bbox for '{view_key}'. Using broad default Western Hemisphere.")
        bbox = (-60, 60, -140, 20)

    # Use bbox center lon to estimate local band
    center_lon = (bbox[2] + bbox[3]) / 2.0
    local_hour = lon_to_local_hour(center_lon)
    desired_band = hour_to_band(local_hour)
    print(f"‚Üí target band for {view_key}: {desired_band} (local hour‚âà{local_hour:02d})")

    # Load candidates
    items = list(scan_sidecars(STATIC_ROOT))

    # 1) Strict: inside bbox + matching band
    strict = [it for it in items if inside_bbox(it["lat"], it["lon"], bbox) and it["time_band"] == desired_band]
    if len(strict) >= n:
        random.shuffle(strict)
        return [it["path"] for it in strict[:n]]

    # 2) Relax band: inside bbox, any band
    in_box = [it for it in items if inside_bbox(it["lat"], it["lon"], bbox)]
    if len(in_box) >= n:
        random.shuffle(in_box)
        return [it["path"] for it in in_box[:n]]

    # 3) Global band match: matching band anywhere
    band_anywhere = [it for it in items if it["time_band"] == desired_band]
    if len(band_anywhere) >= n:
        random.shuffle(band_anywhere)
        return [it["path"] for it in band_anywhere[:n]]

    # 4) Last resort: anything
    random.shuffle(items)
    return [it["path"] for it in items[:n]]

def main():
    import argparse, shutil
    ap = argparse.ArgumentParser()
    ap.add_argument("--view-key", required=True, help="Sanitized view key, e.g., GOES-19_East_752W_Full_Disk_GeoColor_CIRA")
    ap.add_argument("--count", type=int, default=2, help="How many companions to choose")
    args = ap.parse_args()

    picks = choose_companions_for_view(args.view_key, n=args.count)
    if not picks:
        print("‚ùå No companions found.")
        return

    print("\nChosen companions:")
    for p in picks:
        print("  -", p)

    if COPY_FILES:
        out_dir = (OUTPUT_PICK_DIR / args.view_key)
        out_dir.mkdir(parents=True, exist_ok=True)
        # Clear previous picks (optional)
        for old in out_dir.glob("*"):
            if old.is_file():
                try: old.unlink()
                except Exception: pass
        for i, src in enumerate(picks, 1):
            dst = out_dir / f"companion_{i:02d}{Path(src).suffix.lower()}"
            shutil.copy2(src, dst)
        print(f"\nüì¶ Copied {len(picks)} files to: {out_dir}")

if __name__ == "__main__":
    main()
